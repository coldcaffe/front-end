##数组
    数组是一组数据的集合,其中每个数据被称为元素,在数组中可以存放任意类型的元素,数组是一种将一组数据存储在单个变量名下的优雅方式;

    创建数组的几种方式:
        1.利用new方式创建空数组   var arr = new Array();
        2.利用数组字面量创建空数组  var arr = [];
        3.创建有初始值的数组        var arr = [1,0.4,'pink',true]
        字面量方式最常用,声明数组并赋值称为数组的初始化,且数组中可以存放任意类型的数据;

    索引(下标):用于访问数组元素的序号
        数组可以通过索引来访问,设置/修改对应的数组元素,可以通过"数组名[索引]"的形式来获取数组中的元素,这里的访问就是获取得到的意思,索引下不存在元素(超出)时,返回值undefined;

    遍历: 可以通过循环的方式,通过索引值递增将数组数元素遍历出来(计数器当索引号);

    数组长度: 通过'数组名.length'方式,可以访问数组元素的数量(数组长度);


##数组中新增元素
    1.可以通过修改length长度 arr.length = xxx;
        length属性可读写,此方式声明变量未给值,因此新扩充的索引位默认值就是undefined;

    2.索引号增加数组元素(数组扩容) arr[i] = xxx;
        原索引位元素会被替换,没有元素的会新增,跳过索引添加值,中间被跨过的索引会附默认值undefined,追加/修改;        

    冒泡排序
        一种把一系列数据按照一定顺序进行排列显示(从小到大或从大到小)的算法;
        原理:重复的走访要排序的数列,一次比较两个元素,依次将每个数据比对过去,经多次交换最终按顺序排序完毕,其过程类似于泡泡浮起的过程,因此称为冒泡排序;

        1.一共需要的趟数,用外层for循环
        2.每一趟需要交换的次数,用里层for循环(每次循环都有一个位置被确定最大或最小,因此不必重复遍历,所以内循环中要扣除掉这个索引位,避免不必要的循环遍历)
        3.内循环中比对两个相邻元素值的大小,根据排序规则进行赋值;


##函数
    js中可能会定义大量相同或功能相似的代码,此时可以对其进行抽取复用,这些被封装的可被重复调用执行的代码块,被称为js中的函数;

    声明函数:   
        function 函数名(参数1,参数2,...(可为空)) {
            //函数体
        }
        1.function声明函数的关键字 全部小写
        2.函数是做某事,因此函数名一般是动词
        3.函数不被调用情况下,自己不执行

    调用函数:
        函数名(参数...(可为空));
        1.调用函数时不能忘记添加小括号

    函数的参数
        函数的参数作用是,在函数内某些值不能固定,可以通过参数在调用函数时传递不同的值进去,函数参数可以有,也可以没有,且个数不限,但在调用时必须要一一匹配才能输出正确结果;

        形参    在声明函数的小括号里是形参(形式上的参数),可以理解为不用声明的变量(不用加var)
            function 函数名(形参1,形参2,...){}
        实参    在函数调用的小括号里是实参(实际的参数)
            函数名(实参1,实参2,...))

        函数调用时实参和形参个数不匹配的问题:
            1.实参个数与形参个数一致,正常输出结果
            2.实参个数多于形参个数,会按实参顺序依次取到形参需要的数值
            3.实参个数小于形参个数,返回NaN/'传入的字符串'undefined(形参可看做是不用声明的变量,没有实参匹配的形参可以视作没有接受值的变量-undefined,数字加上undefined最终会得到NaN,而字符串会拼接上undefined)

    函数的返回值 
        有时希望函数将值返回给调用者,此时通过return语句就可以实现
        function 函数名() {
            return 需要返回的结果
        }
        函数名();
        1.函数只是实现某种结果,最终的结果需要返回给函数的调用者函数名(),通过return实现
        2.只要函数遇到return,就把后面的结果返回给函数的调用者, 函数名() = return后面的结果

    return终止函数
        1.return语句之后的代码不被执行
        2.return只能返回一个值,如果用逗号隔开多个值,以最后一个为准
        3.可以通过数组的方式同时返回多个值;
        4.有return时返回return后面的值,没有return,默认返回undefined

    break,continue和return的区别
        break:      结束当前的循环体(如for,while))
        continue:   跳出本次循环,继续执行下次循环(如for while)
        return:     不仅可以退出循环,还能够返回return语句中的值,同时还可以技术当前函数体内的代码;

    arguments使用
        当不确定有多少个参数传递时,可以用arguments来获取,在js中arguments实际上是当前函数的一个内置对象,所有函数都内置了一个arguments对象,arguments对象中存储了传递的所有实参;

        arguments展示形式是一个伪数组(非真正的数组),因此可以进行遍历,维数组有如下特点:
            1.具有length属性
            2.按索引方式存储数据
            3.不具有数组的push,pop等方法

    函数间调用
        函数可以调用另一个函数,因为每个函数都是独立的代码块,用于完成特殊任务,因此经常会用到函数相互调用的情况;

    函数的两种声明方式:
        1.利用函数关键字自定义函数(命名函数)
            function fn() {

            }
            fn();

        2.函数表达式(匿名函数)
            var fun = function(aru) {
                console.log('我是函数表达式');
                console.log(aru);
            }
            fun(aru);
            (1)这里的fun是变量名,不是函数名;
            (2)函数表达式声明方式和声明变量差不多,只不过变量里存值,而函数表达式里存的是函数;
            (3)函数表达式也可以进行传递参数;


###JS的作用域
    1.限定一段代码中名字可用性的代码范围,提高了程序逻辑的局部性,增强了程序的可靠性,减少了名字的冲突;
    2.js的作用域(es6)之前:
        全局作用域: 整个script标签,或者是一个单独的js文件
        局部作用域: 在函数内部就是局部作用域,代码的名字只在函数内部起效果和作用

    变量作用域分类
        全局变量: 在函数外部定义的变量
            1.在全局作用域下的变量,在代码任何位置下都可以使用
            2.特殊情况下,在函数内不使用var声明的变量也是全局变量(不建议使用)
 
        局部变量: 在函数内部定义的变量
            1.局部变量只能再函数内部使用
            2.函数的形参实际上就是局部变量

        全局变量和局部变量的区别:
            1.全局变量只有浏览器关闭时才销毁,比较占用内存资源
            2.局部变量但程序执行完毕就会销毁,比较节约内存资源

        块级作用域
            js中没有块级作用域(es6后才出现),方法中逻辑分支等代码块中定义的变量,方法块外可以调用;

    作用域链
        1.只要是代码,就至少有一个作用域
        2.写在函数内部的局部作用域
        3.如果函数中还有函数,那么在这个作用域中就又可以诞生一个作用域
        4.根据在内部函数可以访问外部函数变量的这种机制,用链式查找决定哪些数据能被内部函数访问,根据就近原则依次向上查找的方式，称作作用域链;


##预解析
    1.js代码由浏览器中的js解析器来执行,js解析器在运行js代码时分为两步:预解析和代码执行;
        (1)预解析js引擎会把js里所有的var和function提升到当前作用域的最前面
            预解析分为变量解析(变量提升)和函数预解析(函数提升)
                变量提升:把所有的变量声明提升到当前的作用域最前面   但不提升赋值操作
                函数提升:把所有的函数声明提升到当前作用域的最前面   但不调用函数

        (2)代码执行阶段按照代码书写的顺序从上往下执行

















