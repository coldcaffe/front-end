##面向对象编程介绍
    两大编程思想
        1.面向过程
            POP(Process-oriented programming),分析解决问题所需要的步骤,然后用函数把这些步骤一步一步实现,使用的时候再一个一个的依次调用就可以了;

        2.面向对象  
            OOP(Object Oriented Programming),把事务分解成一个个对象,然后由对象之间分工与合作;在面向对象思想中,每一个对象都是功能中心,具有明确分工,具有灵活,代码可复用,容易维护和开发的优点,更适合多人合作的大型软件项目,面向对象的特性: 封装性,继承性,多态性;
            
    面向过程与面向对象的对比
        面向过程
            优点: 性能比面向对象高,适合跟硬件紧密联系,如单片机嵌入式编程等
            缺点: 没有蛮想对象易维护,易复用,易拓展;

        面向对象
            优点: 易维护,易复用,易扩展,基于封装,继承,多态的特性,系统更低耦合和灵活易维护
            缺点: 性能比面向过程低


##ES6中的类和对象
    面向对象的思维特点:
        面向对象编程主要考虑有哪些对象,按面向对象的思维特点,不断创建对象,使用对象,指挥对象实现功能;
        1.抽取(抽象)对象共同属性和行为组织(封装)成一个类(模板)
        2.对类进行实例化,获取类的对象

    对象
        对象是一个具体的事物,看得见摸得着的实物,如一本书,一个手机...,js中对象是一组无序的相关属性和方法的集合,例如字符串,数值,数组,函数等...,对象是由属性和方法组成的:
            属性: 事物的特征,在对象中用属性来表示(常用名词)
            方法: 事物的行为,在对象中用方法来表示(常用动词)

    类 Class
        ES6中新增了类的概念,可以使用class关键字声明一个类,之后以这个类来实例化对象,类抽象了对象的公共部分,它泛指某一大类(class),而对象则特指某一个通过类实例化获取到的一个具体对象;

    创建类
        类必须使用new实例化对象,类名习惯性定义首字母大写,类名后加小括号,其类中函数和构造函数不用加function,多个函数之间不需添加逗号分隔

        语法:
        class name {
            // class body
        }

        创建实例:
        var xx = new name();

    类 constructor构造函数
        constructor()方法是类的构造函数(默认方法),用于传递参数,返回实例对象,通过new命令生成实例对象时,自动调用该方法,如果没有显示定义,类内部会自动创建一个constructor();

    类使用注意事项:
        1.ES6中类没有变量提升,所以必须先定义类,然后才能通过类实例化对象(同工程中,构造方法在实例化之前)
        2.类里面的共有的属性和方法一定要加this使用
        3.类中this指向问题:constructor里this指向实例对象,方法里的this指向这个方法的调用者


##类的继承
    子类可以继承父类的一些属性和方法,语法:
        class Father{}  //父类
        class Son extends Father{} //子类继承父类
        
        1.继承中,如果实例化子类输出方法,先看子类有没有这个方法,如果有就执行子类的
        2.继承中如果子类没有这个方法,就去查找父类有没有,如果有就去执行父类的这个方法(就近原则)

    super关键字用于访问和调用对象父类上的函数,可以调用父类的构造函数,也可以调用父类的普通函数,但是super必须放到子类的this之前调用(必须先调用父类的构造方法,再使用子类构造方法);



##构造函数和原型
    典型的OOP语言中(如java)都存在类的概念,类就是对象的模板,对象就是类的实例,但在ES6(ECMAScript6.0 2015年发布)之前js并没有引入类的概念,目前浏览器的js版本是ES5版本,大多数高版本的浏览器也支持es6,不过只实现了es6的部分特性和功能,es6职位之前对象不是基于类创建,而是用一种称为构建函数的特殊函数来定义对象和它们的特征;

    利用构造函数创建对象的3种方式:
        1.利用new Object()创建对象
            var obj = new  Ojbect();
        2.利用对象字面量创建对象
            var obj = {};
        3.利用构造函数创建对象
            //定义对象的构造函数
            function Star(uname,age){
                this.uname = uname;
                this.age = age;
                //对象中定义方法
                this.sing = function(){...}
            }
            //对象实例化
            var obj = new Star("ldh",23);

    实例成员和静态成员
        1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问,不可以通过构造函数来访问实例成员

        2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员,静态成员只能通过构造函数来访问,不能通过对象来访问

    构造函数和原型(prototype)
        构造函数方法很好用,但是存在浪费内存的问题,因此可以使用构造函数通过原型分配的函数,因为经过它分配的函数是所有对象共享的;
        
        js规定每一个构造函数都有一个prototype属性,指向一个对象,注意这个prototype就是一个对,这个对象的所有属性和方法,都被构造函数所拥有;因此可以把那些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享这些方法;

        一般情况下,公关属性定义到构造函数里,公关的方法则放到原型对象上;

        对象原型_proto_
            对象都会有一个属性_proto_指向构造函数的prototype原型对象,之所以对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有_proto_原型的存在:
                1._proto_对象原型和原型对象prototyp是等价的
                    ldh._proto_ === Star.prototype
                2._proto_对象原型的意义在于为对象的查找机制提供一个方向,但是它是一个非标准属性,因此实际开发中不可以使用这个属性,它只是内部指向原型对象prototype

        constructor构造函数
            对象原型_proto_和构造函数原型对象prototype里面都有一个constructor属性,constructor称为构造函数,因为它指回构造函数本身;

            constructor主要用于记录该对象引用于那个构造函数,它可以让原型对象重新指向原来的构造函数;如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数;

        原型链,js的成员查找机制(规则)
             1.当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性
             2.如果没有就查找它的原型(即_proto_指向的prototype原型对象)
             3.如果还没有就查找原型对象的原型(Object的原型对象)
             4.以此类推一直找到Object为止(null)
             5._proto_对象原型的意义就在于为对象成员查找机制提供一个方向,或者一条路线

        原型对象中this指向
            1.在构造函数中,里面this指向的是对象实例
            2.原型对象函数里面的this 指向的是 实例对象

        扩展内置对象
            可以通过原型对象,对原来的内置对象进行扩展自定义的方法,比如给数组增加自定义求偶数和的功能;


##继承
    ES6之前没有提供extends继承,可以通过构造函数+原型对象的方式模拟实现继承,被称为组合继承;

    call
        调用这个函数,并且修改函数运行时的this指向,fun.call(thisArg,arg1,arg2...)
            thisArg:    当前调用函数this的指向对象
            arg1,arg2:  传递的其他参数 

    利用构造函数继承父类型属性
        核心原理:通过call()把父类型的this指向子类型的this,这样就可以实现子类型继承父类型的属性

    利用原型对象继承方法
        Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化,此时可以新创建一个父类实例做桥接;另外需注意如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数;


##ES5中新增方法
    es5中新增了一些方便操作数组或者字符串的方法:数组方法,字符串方法,对象方法
    数组方法
        迭代遍历方法:
            forEach()   迭代(遍历)数组  arr.forEach(function(value, index, array){})
            map()
            filter()    筛选数组(会返回新数组) arr.filter(function(value, index){})
            some()      查找数组中元素(返回布尔值) arr.some(function(value){})
            every()

        补充:
            1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来(filter 里面 return 不会终止迭代)
            2. some 也是查找满足条件的元素是否存在  返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环

        foreach和some的区别:
            1.在forEach 里面 return 不会终止迭代
            2.如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高

    字符串方法
        trim()
            string.trim(),会从一个字符串的两端删除空白字符串,不影响原字符串本身,返回的是一个新的字符串;

    对象方法
        1.Object.keys()用于获取对象自身所有的属性
            Object.keys(obj),效果类似for,in,返回一个由属性名组成的数组

        2. Object.defineProperty() 定义新属性或修改原有的属性
            Object.defineProperty(obj,prop,descriptor)
                obj:        必需,目标对象
                prop:       必需,徐定义或修改的属性的名字
                descriptor: 必需,目标属性所拥有的属性,以对象形式书写,具体属性如下:
                    value:          设置属性值,默认为undefined
                    writable:       值是否可重写,true/false(默认false)
                    enumerable:     目标属性是否可被枚举,true/false(默认false)
                    configurable:   目标属性是否可被删除或再次修改特性true/false(默认false)


##函数的定义和调用
    函数的定义方式
        1.函数声明方式function关键字(命名函数)
        2.函数表达式(匿名函数)
        3.new Function()
            var fn = new Function('参数1','参数2'...,'函数体');
            1.Function里面参数都必须是字符串格式
            2.第三种方式执行效率低,也不方便书写,因此较少使用
            3.所有函数都是Function的实例对象
            4.函数也属于对象

    函数的调用方式
        1.普通函数      方法名调用
        2.对象的方法    对象实例.调用即可
        3.构造函数      new构造函数即可调用
        4.绑定事件函数  触发绑定事件调用
        5.定时器函数    系统自动定时执行
        6.立即执行函数  系统立即自动执行


##this
    this的指向,是调用函数的时候确定的,调用方式的不同决定了this的指向不同,一般指向调用者

    调用方式        this指向
    普通函数调用    window
    构造函数调用    实例对象,原型对象中的方法也指向实例对象
    对象方法调用    该方法所属对象
    事件绑定方法    绑定事件对象
    定时器函数      window
    立即执行函数    window

    改变函数内部this指向
        js专门提供了函数方法来更优雅的处理函数内部this指向问题,常见的有bind(),call(),apply()三种:
            1.call方法
                call()一可以调用函数,二可以改变函数的this指向,主要作用是可以实现继承
                fun.call(thisArg,arg1,arg2,...);
                fun.call(...);

            2.apply方法
                通过调用函数的方式,改变函数的this指向 fun.apply(thisArg,[argsArray])
                thisArg:    在fun函数运行时指定的this值
                argsArray:  传递的值,必须包含在数组里面
                返回值就是函数的返回值,因为他就是调用函数,可以利用apply借助于数学内置对象求数组最大值,第二个参数可以改变函数内部的this指向,但是必须是数组(伪数组)

            3.bind方法
                bind()不会调用方法,但是能改变函数内部this指向,返回由指定的this值和初始化参数构造的原函数拷贝,当出现有的函数不需要立即调用,但又想改变这个函数内部的this指向的场景时,此时可以用bind处理

        总结
            相同点: 都可以改变函数内部的this指向
            区别点:
                1.call和apply会调用函数,并且改变函数内部this指向
                2.call和apply传递的参数不一样,call传递参数arg1,arg2...形式,apply必须数组形式[arg]
                3.bind不会调用函数,可以改变函数内部this指向
            主要应用场景:
                1.call经常做继承
                2.apply经常跟数组有关系,比如借助于数学对象实现数组最大值最小值
                3.bind不调用函数,但是还想改变this指向,比如改变定时器内部的this指向
            

##严格模式
    js除正常模式外还提供了严格模式(strict mode),ES5的严格模式(ie10+支持,旧版本被忽略)是采用具有限制性js变体的一种方式,即在严格的条件下运行js代码,对正常js语义做了一些更改:
        1.消除了js语法中的一些不合理/严谨之处,减少了一些怪异行为
        2.消除代码运行的一些不安全之处,保证代码运行的安全
        3.提高编译器效率,增加运行速度
        4.禁用了在EMCAScript的未来版本中可能会定义的一些语法,为未来版本js做好铺垫,比如一些保留字如:class,enum,export,extends,import,super不能做变量名

    开启严格模式
        严格模式可以应用到整个脚本或个别函数中,因此使用中有两种情况:
            1.为脚本开启严格模式
                script不一致时不利于文件合并,此时可以将整个脚本文件放在一个立即执行的匿名函数中,这样独立创建一个作用域而不影响其他script脚本文件;

            2.为函数开启严格模式
                要给某个函数开启严格模式,需要把'use strict'声明放在函数体所有语句之前

        严格模式中变化
            1.变量规定
              正常模式下变量没有声明就赋值则默认为全局变量,严格模式中禁止这种做法,变量必须先用var命令声明,然后再使用;严禁删除已声明变量,如delete x;就是语法错误的;

            2.this指向问题
                以前全局作用域函数中的this指向window对象,严格模式下全局作用域中的this是undefined;
                以前构造函数时不加new也可以调用,当普通函数,this指向全局变量,而严格模式下,如果构造函数不加new调用,this会报错;new实例化的构造函数指向创建的对象实例;
                定时器this还是指向window,事件,对象还是指向调用者;

            3.函数变化
                函数中不能有重名参数,函数必须声明在顶层,新版本js会引入'块级作用域'(ES6中已引入)),为了与新版本接轨,不允许在非函数的代码块内声明函数;


##高阶函数
    高阶函数是对其他函数进行操作的函数,它接收函数作为参数,或将函数作为返回值输出,函数也是一种数据类型,同样可以作为参数,传递给另外一个参数使用,最典型的就是作为回调函数;


##闭包
    闭包(clasure)指有权访问另一个函数作用域中变量的函数---js高级程序设计,简单理解就是一个作用域可以访问另外一个函数内部的局部变量;

    变量作用域
        变量根据作用域的不同可以分为两种: 全局变量和局部变量
        1.函数内部可以使用全局变量
        2.函数外部不可以使用局部变量
        3.当函数执行完毕,本作用域中局部变量会销毁

    闭包的作用
        fn外面的作用域可以访问fn内部的局部变量,延伸了变量的作用范围,闭包也是典型的高阶函数;


##递归
    如果一个函数在内部可以调用其本身,那么这个函数就是递归函数(函数内部自己调用自己),递归函数的作用和循环效果一样,但是由于递归很容易发生'栈溢出'错误,所以必须要加退出条件return;

    浅拷贝和深拷贝
        1.浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用
        2.深拷贝拷贝多层,每一级别的数据都会拷贝
        3.Object.assign(target,...sources) es6新增的方法也可以实现浅拷贝


##正则表达式
    正则表达式(Regular Expression)是用于匹配字符串中字符组合的模式,在js中正则表达式也是对象;通常被用来检索,替换匹配某个模式(规则)的文本,验证表单,过滤敏感词和特定文本提取等;

    正则表达式的特点
        1.灵活性,逻辑性和功能性非常的强
        2.可以迅速的用极简单的方式达到字符串的复杂控制
        3.对刚接触的人比较晦涩难懂
        4.实际开发中,一般都是直接复制写好的正则表达式,但是要求会使用并根据实际需求进行修改

    创建正则表达式
        1. 利用 RegExp对象来创建 正则表达式 var regexp = new RegExp(/123/);
        2. 利用字面量创建 正则表达式 var rg = /123/; 
        3. test方法用来检测字符串是否符合正则表达式要求的规范 rg.test(123);


##正则表达式中的特殊字符
    在线测试,参考runoob网站 https://c.runoob.com/front-end/854/

    正则表达式组成
        一个正则表达式可以由简单的字符组成,如/abc/;也可是简单和特殊字符的组合,如/ab*c/;其中特殊字符也被称为元字符,在正则表达式中是具有特殊意义的专用符号,如^,$,+等,其他字符参考MDN,jquery手册正则部分,或正则测试工具...

    边界符
        边界符(位置符)用来提示字符所处的位置,如果^和$一起,则表示必须是精确匹配
        ^   表示匹配行首的文本(以谁开始)
        $   表示匹配行尾的文本(以谁结束)

    字符类
        字符类表示有一系列字符可选,只要匹配其中一个就可以,所有可供选择的字符都在方括号内
        []  表示有一系列字符可供选择,只要匹配其中一个就可以了,只要能匹配一个就返回true
            [-] 方括号内部-,表示范围符
            [^] 方括号内部^,表示取反符^,在外边表示边界符^

    量词符
        用来设定某个模式出现的次数
        *       重复零次或更多次
        +       重复一次或更多次
        ?       重复零次或一次
        {n}     重复n次
        {n,}    重复n次或更多次
        {n,m}   重复n到m次

    括号总结
        1.{}    大括号表示量词符,里面表示重复次数
        2.[]    中括号表示字符集合,匹配方括号中的任意字符
        3.()    小括号表示优先级
        
    预定义类
        指的是某些常见模式的简写方式
        \d  匹配0-9之间任意数字,相当于[0-9]
        \D  匹配0-9以外字符,相当于[^0-9]
        \w  匹配任意的字母,数字和下划线,相当于[A-Za-z0-9]
        \W  除所有字母,数字和下划线以外的字符,相当于[^A-Za-z0-9]
        \s  匹配空格(包括换行符,制表符,空格符等),相当于[\t\r\n\v\f]
        \S  匹配非空格的字符,相当于[^\t\r\n\v\f]


##正则表达式中的替换
    replace替换
        replace()可以实现替换字符串操作,用来替换的参数可以是一个字符串或者一个正则表达式,但是只能替换第一个匹配值;
        stringObject.replace(regexp/substr,replacement);
            1.第一个参数: 被替换的字符串或者正则表达式
            2.第二个参数: 替换为的字符串
            3.返回值是一个替换完毕的新字符串

    正则表达式参数方式替换
        /表达式/[switch],switch(也被称为修饰符)按照什么样的模式来匹配,有三种值:
            g:  全局匹配
            i:  忽略大小写
            gi: 全局匹配+忽略大小写


##ES6
    ES全称是ECMAScript,是由ECMA国际标准化组织制定的一项脚本语言的标准化规范,ES6实际上是一个泛指,泛指ES2015及后续的版本

##ES6的新增语法
    let es6中新增的用于声明变量的关键字
        1.let声明的变量只在所处的块级有效
        2.使用let关键字声明的变量才具有块级作用域,var声明的变量则不具备块级作用域的特性;
        3.防止循环变量变成为全局变量
        4.使用let关键字声明的变量没有变量提升(只能先声明再使用)
        5.使用let声明变量,存在暂时性死区(变量与块进行绑定,只能使用当前块内定义的同名变量)

    const 声明常量,常量就是值(内存地址)不能变化的量
        1.具有块级作用域
        2.声明常量时必须赋初始值
        3.常量赋值后,值不能更改

    let,const,var的区别
        1.使用var声明的变量,其作用域为该语句所在的函数内,且存在变量提升现象
        2.使用let声明的变量,其作用域为该语句所在的代码块内,不存在变量提升
        3.使用const声明的是常量,在后面的代码逻辑中不能修改该常量的值(修改值内存地址)

        var             let             const
        函数级作用域    块级作用域      块级作用域
        变量提升        不存在变量提升  不存在变量提升
        值可更改        值可更改        值不可更改


##ES6的内置对象扩展
    解构赋值
        ES6中允许从数组/对象中提取值,按照对应位置,对变量赋值,对象也可以实现解构,解构不成功,返回值为undefined;也可从数组或对象取值,然后将提取的值赋值给另外的变量(类似于别名);

    箭头函数
        es6中新增的定义函数的方式,用来简化函数定义语法
        () => {}
        const fn = () => {}

        1.如果函数体只有一句代码,且代码的执行结果就是返回值时,可以省略大括号
        2.如果形参只有一个,形参外侧的小括号也是可以省略的

    箭头函数中的this关键字
        箭头函数不绑定this关键字,箭头函数中的this指向的是函数定义位置的上下文this;

    剩余参数
        剩余参数允许将一个不定数量的参数表示为一个数组

    Array的扩展方法
        扩展运算符(展开语法)    
            1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列
            2.扩展运算符可以用于数组合并(数组合并,或push两种方式)
            3.将类数组或可遍历对象转换为真正的数组

        构造函数方法 Array.from()
            将类数组或可遍历对象转换为真正的数组,方法还可以接受第二个参数,作用类似于数组的map方法,用来对每个元素进行处理,将处理后的值放入返回的数组;

        实例方法
            find()  用于找出第一个符合条件的数组成员,如果没有找到则返回undefined
            findIndex() 用于找出第一个符合条件的数组成员的位置,如果没有找到则返回-1
            includes()  表示某个数组是否包含给定的值,返回布尔值

    String的扩展方法
        模板字符串  ES6新增的创建字符串的方式,使用反引号方式 `xxx`
            1.模板字符串中可以解析变量 `${xxx}`
            2.模板字符串中可以换行
            3.模板字符串中可以调用函数`${fn()}...`

        实例方法
            startsWith() 和 endsWidth() 表示参数字符串是否在源字符串的头部/尾部,返回布尔值

            repeat()    表示将原字符串重复n次,返回一个新字符串

    Set数据结构
        ES6提供了新的数据结构Set,类似于数组,但是成员的值都是唯一的,没有重复的值,Set本身是一个构造函数,用来生成Set数据结构: const s = new Set();set也可以接收数组用来初始化;

        实例方法
            add(value):     添加某个值,返回Set结构本身
            delete(value):  删除某个值,返回一个布尔值,表示删除是否成功
            has(value):     返回一个布尔值,表示该值是否为Set的成员
            clear():        清除所有成员,没有返回值

        遍历
            Set结构的实例与数组一样,也拥有forEach方法,用于对每个成员执行某种操作,没有返回值     s.forEach(value => console.log(value))






