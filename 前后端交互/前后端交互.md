##服务器对外提供了哪些资源
    查看资源信息
        1.进入chrome开发者模式
        2.点击network中DOC选项,然后刷新页面

    网页中如何请求数据
        数据也是服务器对外提供的一种资源,资源必然要通过 请求-处理-响应 的方式获取;
        如果要在网页中请求服务器上的数据资源,需要用到XMLHttpRequest(xhr)对象,xhr是浏览器提供的js对象,通过它可以请求服务器上的数据资源; var xhrobj = new XMLHttpRequest();

    资源请求方式
        客户端请求服务器时请求方式有多种,最常见的有get和post请求
            get:通常用于获取服务端资源(向服务器要资源)
            post:常用于向服务器提交数据(往服务器发送资源)


##了解Ajax
    Ajax全称Asynchronous JavaScript And XML(异步JavaScript和XML),在网页中通过XMLHttpRequest对象和服务器进行数据交互的方式就是Ajax;Ajax可以更轻松的实现网页与服务器之间的数据交互;

    Ajax的典型应用场景
        搜索提示: 当输入搜索关键字时,通过ajax的形式动态加载搜索提示列表
        数据分页显示: 点击页码时,通过ajax的形式根据页码值动态刷新表格的数据
        数据的增删改查: 数据的增删改查,都需要通过ajax的形式来实现数据的交互


##jQuery中的Ajax
    浏览器提供的XMLHttpRequest用法比较复杂,所以jquery对XMLHttpRequest进行封装,提供了一些列ajax相关函数,极大地降低了Ajax的使用难度;最常用三个方法如下:
        $.get()     语法: $.get(url,[data],[callback])
                        url         要请求的资源地址
                        data        请求资源期间要携带的参数
                        callback    请求成功时的回调函数

        $.post()    语法: $.post(url,[data],[callback])
                        url         要提交的资源地址
                        data        要提交的数据
                        callback    数据提交成功时的回调函数

        $.ajax()    是一个功能比较综合的函数,允许进行更详细的配置
            $.ajax({
                type: '',   //请求方式,如get或post(大小写均可)
                url: '',    //请求的url地址
                data: {},   //请求要携带的数据
                success: function(res){}    //请求成功后的回调函数
            })


##接口
    使用ajax请求数据时,被请求的URL地址,就叫做数据接口,同时每个接口必须要有请求方式;

    接口文档
        接口文档可以包含很多信息,也可以按需进行精简,不过一个合格的接口文档,应该包含一下6项内容,从而为接口调用提供依据:
            1.接口名称: 用来标识各个接口的简单说明,如登陆接口等
            2.接口URL: 接口的调用地址
            3.调用方式: 接口的调用方式 get/post
            4.参数格式: 接口要传递的参数,每个参数必须包含参数名称,参数类型,是否必选,参数说明这4项内容
            5.响应格式: 接口的返回值的详细描述,一般包含数据名称,数据类型,说明等3项内容
            6.返回示例(可选): 通过对象的形式,例举服务器返回数据的格式


##Form表单
    表单在网页中主要负责数据采集功能,HTML中的<form>标签就是用于采集用户输入信息,然后通<form>标签的提交操作,把采集到的信息提交到服务端进行处理;

    表单的组成部分
        1.表单标签  <form></form>
        2.表单域    包含文本框,密码框...等等<input>相关类型提交信息
        3.表单按钮  <button type = 'submit'>

    <form>标签的属性
        <form>标签用来采集数据,<form>标签属性则是用来规定如何把采集到的数据发送到服务器
        action      URL地址             规定提交表单时向何处发送表单数据
                    未指定时默认当前页面地址,提交表单后会跳转到该属性指定URL地址;

        method      get/post            规定以何种方式提交表单数据
                    get适合少量简单数据,post适合大量复杂的数据,实际开发用post较多;

        enctype     application/...     规定发送表单数据之前如何进行数据编码
                    application             在发送前编码所有字符(默认)
                    x-www-form-urlencoded   不对字符编码
                    multipart/form-data     使用包含文件上传的表单时必须使用这个
                    text/plain              空格转换为'+',但不对特殊字符编码(很少用)

        target      _blank/_self...     规定在何处打开action URL
                    _blank      在新窗口中打开
                    _self       默认,在相同的框架中打开
                    _parent     在父框架中打开(很少用)
                    _top        在整个窗口中打开(很少用))
                    framename   在指定的框架中打开(很少用)

    表单的同步提交及缺点
        通过点击submit按钮,触发表单提交操作,从而使页面跳转到action URL的行为,叫做表单的同步提交;

        缺点:
            1.form表单提交后页面会发生跳转,跳转到action URL所指向的地址,用户体验很差;
            2.表单同步提交后,页面之前的状态和数据会丢失
        解决方案:   表单只负责采集数据,由Ajax负责将数据提交到服务器

##通过Ajax提交表单数据
    监听表单提交事件
        jquery中有以下两种方式可以坚挺到表单的提交事件:
            $('#form1').submit(function(){...})
            $('#form1').on('submit',function(){...})

    阻止表单默认提交行为
        当监听到表单的提交事件后,可以调用事件的event.preventDefault()函数,来阻止表单的提交和页面的跳转:
            $('#form1').submit(function(e){e.preventDefault()}})
            $('#form1').on('submit',function(e){e.preventDefault()})

    快速获取表单中的数据
        1.serialize()函数       简化表单中数据的获取操作,可以一次性获取到表单中所有数据 
            $(selector).serialize() 在使用serialize()获取数据时,必须为每个表单元素添加                          name属性


##模板引擎
    模板引擎可以根据程序员指定的模板结构和数据,自动生成一个完整的HTML页面(避免代码拼接方式的后续难以维护)

    模板引擎的好处
        1.减少了字符串的拼接操作
        2.时代吗结构更清晰
        3.是代码更易于阅读与维护


#art-template模板引擎
    art-template是一个简约超快的模板引擎(新手友好)

    安装
        1.浏览器中访问art-template的github.io路径
        2.链接右键另存为,下载到本地
        3.通过script标签加载到网页使用

    使用步骤
        1.导入art-template
        2.定义数据
        3.定义模板
        4.调用template函数
        5.渲染HTML结构

    标准语法
        art-template提供了{{}}这种语法格式,在{{}}内可以进行变量,对象属性,三元表达式,逻辑或,加减乘除,或循环数组等输出操作;
        {{value}},{{obj.key}},{{obj['key']}},{{a?b:c}},{{a||b}},{{a+b}}

        原文输出    {{@ value}}
            如果要输出的value值中包含HTML标签结构,则需要使用原文输出,才能保证HTML正常渲染

        条件输出
            如果要实现条件输出,可以在{{}}中使用if...else...的方式,按需输出
            {{if value}} 按需内容 {{/if}}
            {{if v1}} 按需内容 {{else if v2}} 按需输出内容 {{/if}}
        
        循环输出
            可以在{{}}内通过each语法循环数组,当前循环的索引使用$index进行访问,当前的循环项使用$value进行访问
            {{each arr}}
                {{$index}} {{$value}}
            {{/each}}

        过滤器      {{value | filterName}}
            过滤器本质就是一个function函数,语法类似管道操作符,上一个输出作为下一个输入
            template.defaults.imports.filterName = function(value){//return处理结果}


##模板引擎的实现原理
    正则与字符串操作
        exec()函数用于检索字符串中的正则表达式的匹配,如果字符串中有匹配的值,则返回该匹配值,否则返回null;    RegExpObject.exec(string)

        分组
            正则表达式中()包起来的内容表示一个分组,可以通过分组来提取想要的内容;

        字符串的replace函数
            replace()函数用于在字符串中用一些字符替换另一些字符

        多次/while循环replace
            将数据中的值替换到模板中

        自定义模板引擎
            function template(id, data) {
                var str = document.getElementById(id).innerHTML
                var pattern = /{{\s*([a-zA-Z]+)\s*}}/

                var pattResult = null
                while (pattResult = pattern.exec(str)) {
                    str = str.replace(pattResult[0], data[pattResult[1]])
                }
                return str
            }


##Ajax加强&XMLHttpRequest
    XMLHttpRequest简称xhr,是浏览器提供的js对象,通过它可以请求服务器上的数据资源,jquery中的Ajax函数就是基于xhr对象封装出来的;

    使用xhr发起get请求
        1.创建xhr对象
        2.调用opean函数,指定请求方式与url地址
        3.调用send函数,发起ajax请求
        4.监听onreadystatechange事件
            4.1 监听xhr对象的请求状态readyState,与服务器响应的状态status
            4.2 获取服务器响应回的数据responseText

    xhr对象的readyState属性
        readyState属性用于表示当前Ajax请求所处的状态,每个Ajax请求必然处于以下状态之一:
        值      状态                描述
        0       UNSENT              xhr对象已创建,但尚未调用open方法
        1       OPENED              open()方法以备调用
        2       HEADERS_RECEIVED    send()方法已调用,响应头也已被接受
        3       LOADING             数据接受中,此时response属性中已包含部分数据
        4       DONE                Ajax请求完成,意味数据传输已经彻底完成或失败

    使用xhr发起带参数的get请求
        只需在调用xhr.open期间,为url地址指定参数即可('?id=1&...'),这种在url地址后面拼接的参数,叫做查询字符串.查询字符串指的就是在URL末尾加上用于向服务器发送信息的字符串(变量)

        get请求携带参数的本质
            无论使用$.ajax()或是$.get(),又或者直接使用xhr发起get请求,需要携带参数时,本质上都是直接将参数以查询字符串的方式追加到url地址后面,发送到服务器的;

    URL编码与解码
        url中不允许出现中文字符,如果需要包含这样的中文字符,则必须对中文字符进行编码(转义),使用英文字符去表示非英文字符
        url编码的原则:使用安全的字符(无特殊用途或意义的可打印字符),去表示那些不安全的字符

        encodeURI() 编码的函数
        decodeURI() 解码的函数
        由于浏览器会自动对URL地址进行并操作,因此大多数情况下无需程序员关心URL地址的编解码

    使用xhr发起POST请求
        1.创建xhr对象
        2.调用xhr.open()函数
        3.设置Content-Type属性
        4.调用xhr.send()函数,同时指定要发送的数据
        5.监听xhr.onreadystatechange事件


##数据交换格式
    服务器端与客户端进行数据传输与交换的格式,前端领域常用的有xml和json,重点了解json

    XML
        xml(Extensible Markup Landuage)可扩展标记语言,因此xml和html类似,也是标记语言,但是二者没有任何关系;html被设计用于描述网页内容,是网页内容载体;xml设计用于传输和存储数据,是数据的载体;

        缺点
            1.xml格式臃肿,和数据无关代码多,体积大,传输效率低
            2.在js中解析xml较麻烦

    JSON
        json(JavaScript Object Notation)即js对象表示法,json就是js对象和数组的字符串表示法,使用文本表示一个js对象或数组信息,因此json本质就是字符串;json是一种轻量级的文本数据交换格式,作用上类似于XML,专用于计算机与网络间存储和传输数据,但是比XML更小,更快,更易解析,目前json已经成为了主流的数据交换格式;

        json的两种结构
            json中包含对象和数组两种结构,通过这两种结构的相互嵌套,可以表示各种复杂数据结构

            对象结构
                {key:value,...}的键值对结构,key必须是使用英文的双引号包裹的字符串,value的数据结构可以是数字,字符串,布尔值,null,数组,对象6种类型;

            数组结构
                []括起来的内容,数据结构为["java",19,[...],true...],数组中数据类型可以是数字,字符串,布尔值,null,数组,对象6种类型;

            json语法注意事项
                1.属性名必须使用双引号包裹
                2.字符串类型的值必须使用双引号包裹
                3.json中不允许使用单引号表示字符串
                4.json中不能写注释
                5.json的最外层必须是对象或数组格式
                6.不能使用undefined或函数作为json的值

            json和js对象的互转
                JSON.parse()        从json字符串转换为js对象,json反序列化
                JSON.stringify()    从js对象转为json字符串,json序列化

            序列化和反序列化
                序列化:把数据对象转换为字符串的过程
                反序列化:把字符串转换为数据对象的过程


##封装自己的Ajax函数
    处理data参数
        itheima.js


##XMLHttpRequest Level2的新特性
    旧版XMLHttpRequest的缺点
        1.只支持文本数据的传输,无法用来读取和上传文件
        2.传输和接受数据时,没有进度信息,只能提示有没有完成
    
    XMLHttpRequest level2的新功能
        1.可以设置HTTP请求的时限
        2.可以使用FormData对象管理表单数据
        3.可以上传文件
        4.可以获得数据传输的进度信息

    设置http请求时限
        有时Ajax操作很耗时,网速慢时会让用户久等,新版本增加了timeout属性,可以社会中http请求时限: xhr.timeout = 3000;过了这个时限就自动停止http请求,与此配套的还有一个timeout事件,用于指定回调函数:
            xhr.ontimeout = function(event){
                alert('请求超时')
            }

    FormData对象管理表单数据
        ajax操作往往用来提交表单数据,为了方便表单处理,html5新增了一个formdata对象,可以模拟表单操作;formdata对象也可以用来获取网页表单的值;

    上传文件
        新版xmlhttprequest对象,不仅可以发送文本信息,还可以上传文件
        1.定义UI结构
        2.验证是否选择了文件
        3.向FormData中追加文件
        4.使用xhr发起上传文件的请求
        5.监听onreadystatechange事件

    显示文件上传进度
        新版本xmlhttprequest对象中可以通过xhr.upload.onprogress事件,来获取到文件的上传进度;结合bootstrap的进度条,可以实现上传进度展示;


##jQuery高级用法
    jquery实现文件上传


    jquery实现loading效果
        1.ajaxStart(callback)   ajax请求开始时,执行ajaxStart函数,可以在ajaxStart的callback中显示loading效果;
            $(document).ajaxStart(function(){ //自1.8开始,该方法只能被附加到文档
                $('#loading').show();
            })
        $(document).ajaxStart()会监听当前文档内所有的ajax请求;

        2.$(document).ajaxSop(callback) ajax请求结束时执行,可以在callback中隐藏loading效果


##axios
    axios是专注于网络数据请求的库,相较于原生的xmlhttprequest对象,axios简单易用,而相较于jquery,axios更加轻量化,只专注于网络数据请求;

    axios发起get请求
        axios.get('url', { params: {/*参数*/}}).then(callback)

    axios发起post请求
        axios.post('url', { /*参数*/}).then(callback)

    直接使用axios发起请求
        axios提供了类似jquery中$.ajax()的函数

        axios({
        method: '请求类型,get/post',
        url: '请求url地址',
        data: {/*post数据*/}
        params: {/*get参数*/}
      }).then(callback)


##同源策略和跨域
    同源策略
        如果两个页面的协议,域名和端口(默认80)都相同,则两个页面具有相同的源
        同源策略(same origin policy)是浏览器提供的一个安全功能,限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互,这是一个用于隔离潜在恶意文件的重要安全机制
            1.无法读取非同原网页的cookie,localstorage和indexedDB
            2.无法接触非同源网页的DOM
            3.无法向非同源地址发送ajax请求

    跨域
        同源指两个url的协议,域名,端口一致,反之则为跨域,浏览器允许发起跨域请求,但是跨域请求回来的数据会被浏览器拦截,因此无法被页面获取到;

        如何实现跨域请求
            跨域请求主要2种解决方案: JSONP和CORS
            jsonp:出现的早,兼容性好(兼容低版本IE),缺点是只支持get请求,不支持post请求
            cors:出现的晚,是W3C标准,属于跨域ajax的根本解决方案,支持get和post请求,但是不兼容低版本ie


##JSONP
    jsonp的实现原理
        由于浏览器同源策略限制,网页中无法通过ajax请求非同源的接口数据,但是<script>标签不受浏览器同源策略的影响,因此可以通过src属性,用函数调用的形式请求非同源的js脚本,接受跨域接口响应的数据;

    jsonp的缺点
        由于jsonp是通过<script>的src属性来实现跨域数据获取的,因此只支持get数据请求,不支持post请求;此外jsonp和ajax没有任何关系,不能把jsonp请求数据的方式叫做ajax,因为jsonp没有用到xmlhttprequest这个对象;

    jquery中的jsonp
        jquery中的ajax函数,除了可以发起真正的ajax数据请求外,还能够发起jsonp数据请求
            $.ajax({
                url: '',
                // 代表我们要发起JSONP的数据请求
                dataType: 'jsonp',
                //发送到服务器端的参数名称,默认值为callback
                jsonp: 'callback',
                //自定义的回调函数名称,默认值为jQeuryxxx格式(不自己定义就会随机生成一个)
                //默认情况下使用jquery发起jsonp请求,请求链接上会自动携带一个callback=jQueryxx的参数  // (jQueryxx是随机生成的一个回调函数名称)
                jsonpCallback: 'abc',
                success: function (res) {...}
            })

            如果想要自定义jsonp的参数及回调函数,可以通过jsonp和jsonpCallback两个参数来指定;

    jquery中jsonp的实现过程
        jquery中jsonp也是通过<script>标签的src属性实现跨域数据访问,只是jquery采用的是动态创建和移除<script>标签的方式,来发起jsonp数据请求
            1.发起jsonp请求时,动态向<header>中append一个<script>标签;
            2.在jsonp请求成功后,动态从<header>中移除刚才append进去的<script>标签;


##防抖和节流
    防抖策略(debounce)是当事件被触发后,延迟n秒后再执行回调.如果在这n秒内事件又被触发,则重新计时;好处是可以保证事件在一定时间段内不会频繁被触发执行;

    防抖的应用场景
        用户在输入框内输入字符串时,可通过防抖策略,只在输入完后才执行查询的请求,这样可以有效减少请求次数,节约请求资源;

    节流
        节流策略(throttle),顾名思义可以减少一段时间内事件的触发频率;

    节流的应用场景(节流阀)
        1.鼠标连续不断的触发某事件(如点击),只在单位时间内只触发一次;
        2.懒加载时要监听计算滚动条的位置,但不必每次滑动都触发,可以降低计算的频率,而不必去浪费cpu资源;

        鼠标跟随效果

    防抖和节流的总结
        防抖: 如果事件被频繁触发,防抖能保证只有最后一次触发生效,前面N多次的触发都被忽略;
        节流: 如果事件被频繁触发,截流能够减少事件触发的频率,因此节流是有选择性的执行一部分事件;


##HTTP协议
    通信协议(Communication Protocol)是指通信的双方完成通信所必须遵守的规则和约定;

    互联网通信中的HTTP协议
        客户端与服务端之间要实现网页内容的传输,通信双方必须遵守网页内容的传输协议,网页内容又叫做超文本,因此网页内容的传输协议又叫做超文本传输协议(hyperText Transfer Protol),简称HTTP协议

    http协议的交互模型
        采用了请求/响应的交互模型


##http请求消息
    由于http协议属于客户端浏览器和服务器之间的通信协议,因此客户端发起的请求叫做http请求,客户端发送到服务器的消息叫做http请求消息;http请求消息又叫做HTTP请求报文;

    http请求消息的组成部分
        http请求消息由请求行(request line),请求头部(header),空行和请求体4个部分组成;

        请求行
            由请求方式,url和http协议版本3个部分组成,它们之间使用空格隔开;

        请求头部
            用于描述客户端的基本信息,从而把客户端相关信息告知服务器,比如User-agent 用来说明当前是什么类型浏览器;content-type用于描述发送到服务器的数据格式;accept用于描述客户端能够接收到什么类型的返回内容;accept-language用于描述客户端期望接收那种人类语言的文本内容;

            请求头部由多行键值对组成,每行的键和值之间用英文的冒号分隔;

        空行
            最后一个请求头字段的后面是一个空行,通知服务器请求头部至此结束,请求消息中的空行用于分隔请求头部与请求体;

        请求体
            请求体中存放的是要通过post方式提交到服务器的数据,只有post有请求体,get没有

    http请求方法
        http请求方法,属于http协议的一部分,请求方法的作用是:用来表名要对服务器上的资源执行的操作,最常见的请求方法是get和post;

        请求方法如下: get,post,put,delete  head,options,connect,trace,patch



##http响应状态码
    http响应状态码(HTTP status code),也属于http协议的一部分,用来标识响应的状态,响应状态码会随着响应消息一起被发送至客户端浏览器,浏览器根据服务器返回的响应状态码,就能知道此次http请求的结果是成功还是失败;

    http响应状态码的组成及分类
        http状态码由三个十进制数字组成,第一个十进制数字定义了状态码的类型,后两个数字用来对状态码进行细分,http状态码共分为5种类型: 1xx,2xx,3xx,4xx,5xx;

    1. 2xx 成功相关的响应状态码,表示服务器已经成功接收到请求并进行处理;
    2. 3xx 重定向相关响应状态码,表示服务器要求客户端重定向,需要客户端进一步操作,以完成资源请求;
    3. 4xx 客户端错误相关响应状态码,表示客户端的请求有非法内容,从而导致这次请求失败;
    4. 5xx 服务端错误相关的响应状态码,表示服务器未能正常处理客户端的请求而出现意外错误;


##http响应消息
    http响应消息就是服务器响应给客户端的消息内容,也叫做响应报文;

    http响应消息的组成部分
        http响应消息由状态行,响应头部,空行和响应体4个部分组成;

    状态行
        状态行由http协议版本,状态码和状态码的描述文本3个部分组成,它们之间用空格隔开; 

    响应头部
        响应头部用于描述服务器的基本信息,响应头部由多行键/值对组成,每行的键值之间用英文的冒号分隔;  

    空行
        在最后一个响应头部字段结束之后,会紧跟一个空行,用于通知客户端响应头部至此结束,响应消息中的空行用来分隔响应头部与响应体;

    响应体
        响应体中存放了服务器响应给客户端的资源内容;


##大事件项目
    layui,iconfont,cropper
    

## Node.js
    为什么js可以在浏览器中被执行
        不同的浏览器使用不同的js解析引擎:
        Chrome      V8(性能最好,推荐使用)
        Firefox     OdinMonkey(奥丁猴)
        Safri       JSCore
        IE          Chakra(查克拉)
        etc...

    为什么js可以操作DOM和BOM
        每个浏览器都内置了DOM和BOM这样的API函数,因此浏览器中的js才可以调用他们

    Node.js简介
        node.js是一个基于Chrome v8引擎的js运行环境,作为一个js的运行环境,node提供了基础的功能和api,基于node的这些基础功能,很多强大的工具和框架如雨后春笋出现,大前端生态:
            1.基于Express框架,可以快速构建Web应用
            2.基于Electron框架,可以构建跨平台的桌面应用
            3.基于restify框架,可以快速构建API接口项目
            4.读写和操作数据库,创建使用的命令行工具辅助前端开发,etc...

    环境安装
        node.js官网下载安装包,然后在计算机上双击安装即可;

        区分LTS版本和Current版本不同
            1.LTS为长期稳定版,推荐追求稳定的企业级项目使用
            2.CUrrent为新特性尝鲜版,推荐热衷尝试新特性用户使用,不推荐企业级项目中使用current版本;

        查看已安装的node.js的版本号
            打开终端,在终端(win + r后,输入cmd)中输入命令 node -v后,按下回车键,即可查看已安装的node.js的版本号;

        node.js环境中运行js
            cmd或powershell中,使用node 文件名.js方式执行js

            终端中快捷键
                windows中powershell或cmd,可以通过如下快捷键来提高操作效率:
                1.使用'上箭头',可以快速定位到上一次执行的命令
                2.使用tab键,快速补全路径
                3.使用esc,快速清空当前已输入命令
                4.使用cls,清空终端


##fs文件系统模块
    fs是node官方提供用于操作文件的模块,提供了一系列的方法和属性,满足对文件的操作需求:
        1.fs.readFile()     用于读取指定文件中的内容
            fs.readFile(path[,options],callback)
                path        文件路径
                options     可选参,表示以什么编码格式来读取文件
                callback    文件读取完成后,通过回调函数拿到读取的结果

        2.fs.writeFile()    用于向指定的文件中写入内容
            fs.writeFile()(file,data[,options],callback)
                file        文件路径字符串
                data        要写入的内容
                options     可选参,表示以什么编码格式来写入文件,默认utf8
                callback    文件写入完成后的回调函数
            只能创建文件,不能创建目录;重复调用写入同一文件,新写入内容会覆盖之前的旧内容;

        如果要在js代码中使用fs模块操作文件,需要按如下方式导入: const fs = require('fs');

    fs模块-路径动态拼接的问题
        使用fs模块操作文件时,如果提供的操作路径是以./或../开头的相对路径时,很容易出现路径动态拼接错误的问题(代码运行时,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径)

        解决方案: 
            1.在使用fs模块操作文件时,直接提供完整的路径,不要提供./或../开头的相对路径,从而防止路径动态拼接的问题(但是移植性差,不利于维护);
            2.使用__dirname表示当前文件所处的目录(__是双下划线)

    path路径模块
        path模块是node.js官方提供,用来处理路径的模块,提供了一系列的方法和属性,用于解决用户对路径的处理需求:
            const path = require('path')    导入path模块

            path.join()     将多个路径片段拼接成一个完整的路径字符串
                path.join([...paths])
                    ...paths<string>:   路径片段的序列('../'具有抵消前一个文件夹目录路径的功能)
                    返回值:             <string>
                凡是设计路径拼接的操作,都要用path.join()处理,不能直接用'+'进行字符串拼接
            
            path.basename() 可以获取路径中的最后一部分,用于从路径字符串中将文件名解析出来
                path.basename(path[,ext])
                    path<string>    必选,表示一个路径的字符串
                    ext<string>     可选,表示文件扩展名
                    返回:           <string>,表示路径中的最后一部分(文件名)


##http模块
    http模块是node.js官方提供用来创建web服务器的模块,通过http模块提供的http.createServer()方法,能够把一台普通的电脑变成一台web服务器,从而对外提供web资源服务;服务器和普通电脑的区别就在于服务器上安装了web服务器软件,如IIS,Apache等;node.js中不需iis,apache这些第三方服务器软件,可以直接基于node的http模块

        const http = require('http');

    IP地址
        ip地址就是互联网上每台计算机的唯一地址,只有知道对方ip地址前提下,才能与对应电脑之间进行数据通信;ip地址通常用'点分十进制'表示成(a.b.c.d)格式,a,b,c,d都是0~255之间的十进制整数,如(192.168.1.1);

        1.互联网每台web服务器都有自己的ip地址,例如可以ping www.baidu.com,查看百度服务器的ip地址;
        2.本地开发时ip可以输入127.0.0.1,将自己的电脑当做一台服务器进行访问;

    域名和域名服务器
        ip地址是一串不直观的长串数字,于是又发明了另一套字符型的地址方案,即域名(Domain name)地址;ip地址和域名是一一对应关系,这份关系存放在DNS(Domain name server域名服务器)中,域名服务器是提供ip地址和域名之间转换服务的服务器;

        1.单纯使用ip地址,互联网中电脑也能使用,但有域名下更加方便;
        2.开发本地测试期间,127.0.0.1对应域名localhost,代表本地电脑,使用效果没区别;

    端口号
        一台服务器中可以运行上千个web服务,每个服务都对应一个唯一的端口号,客户端发送过来的网络请求可以通过端口号,准确的被交给对应的web服务进行处理;

        1.每个端口号不能同时被多个web服务占用
        2.实际应用中,url中的80端口默认可以被省略;

    创建最基本的web服务器
        1.导入http模块
            const http = require('http');

        2.创建web服务器实例
            调用http.createServer(),快速创建实例

        3.为服务器实例绑定request事件,监听客户端的请求
            server.on('request',(req,res) =>{})

        4.启动服务器,调用服务器实例的listen()方法
            server.listen(80,() =>{})

    req请求对象
        服务器接收到了客户端的请求,就会调用server.on()为服务器绑定的request事件处理函数;事件处理函数中可以通过${req.属性}方式,访问与客户端相关的数据或属性; 

    res响应对象
        在服务器的request事件处理函数中,可以用${res.属性}方式获取服务器相关数据或属性;

    解决中文乱码问题
        当调用res.end(),向客户端发送中文内容时,会出现乱码问题,此时需要手动设置内容的编码格式:
        server.on('request',(req,res) =>{
            res.setHeader('Content-Type', 'text/html; charset=utf-8')
        })

    根据不同的url响应不同的html内容
        1. 获取请求的 url 地址
        2. 设置默认的响应内容为 404 Not found
        3. 判断用户请求的是否为 / 或 /index.html 首页
        4. 判断用户请求的是否为 /about.html 关于页面
        5. 设置 Content-Type 响应头，防止中文乱码
        6. 使用 res.end() 把内容响应给客户端


##模块化的基本概念
    模块化是指解决一个复杂问题时,自顶向下逐层把系统划分成若干模块的过程,对整个系统而言,模块是可组合,分解和更换的单元;

    编程领域中的模块化
        编程领域模块化,就是遵守固定的规则,把一个大文件拆成独立并相互依赖的多个小模块,代码模块化拆分好处:
            1.提高了代码的复用性    
            2.提高了代码可维护性
            3.可以实现按需加载

        模块化规范
            模块化规范是对代码进行模块化的拆分与组合时,需要遵守的那些规则,如使用什么语法格式引用模块,及在模块中使用什么语法格式向外暴露成员;好处是大家都遵守同样的模块化规范写代码,降低了沟通成本,极大方便了各个模块之间的相互调用;


#Node.js中的模块化
    node.js中模块的分类
        node.js根据模块来源的不同,将模块分为3大类:
            1.内置模块(由node.js官方提供,例如fs,path和http等)
            2.自定义模块(用户创建的每个.js文件,都是自定义模块)
            3.第三方模块(第三方开发,非官方提供,也不是用户创建的自定义模块,使用前需先下载)

        使用强大的require()方法,可以加载需要的内置模块,用户自定义模块,第三方模块进行使用;

    模块作用域
        和函数作用域类似,在自定义模块中定义的变量,方法等成员,只能在当前模块内被访问,这种模块级别的访问限制,叫做模块作用域;

        好处: 防止了全局变量污染的问题;

    向外共享模块作用域中的成员
        1.module对象
            每个.js自定义模块中都有一个module对象,里面存储了和当前模块有关的信息;

        2.module.exports对象
            在自定义模块中,可以使用module.exports对象,将模块内的成员共享出去,供外界使用,外界用require()方法导入自定义模块时,得到的就是module.exports所指向的对象(默认为{});

        3.共享成员时的注意点
            使用require()方法导入模块时,导入的结果永远以module.exports指向的对象为准;

        4.exports对象
            为简化向外共享成员的代码,node提供了exports对象,默认情况下exports和module.exports指向同一个对象,最终共享的结果还是以module.exports指向的对象为准;

        5.exports和module.exports的使用误区
            时刻谨记require()模块时,得到的永远是module.exports指向的对象,且为防止混乱,建议不要再同一个模块中同时使用exports和module.exports;

    node.js中的模块化规范
        node遵循了commonJS模块化规范,CommonJS规定了模块的特性和各模块之间如何相互依赖,commonjs规定:
            1.每个模块内部,module变量代表当前模块
            2.module变量是一个对象,它的exports属性,即module.exports是对外的接口
            3.加载某个模块,其实是加载该模块的module.exports属性,require()方法用于加载模块


##npm与包
    node.js中的第三方模块又叫做包,不同于node.js中内置模块和自定义模块,包是由第三方个人或团队开发出来的,免费供所有人使用;node.js中的包都是免费开源的;

        搜索包文件: npm.com

    为什么需要包
        由于node.js内置模块仅提供了一些底层的API,导致基于内置模块进行项目开发时效率很低,因此基于内置模块封装出了包,提供了更高级,方便的API以提高开发效率,包和内置模块之间的关系,类似于jQuery和浏览器内置API之间的关系;

        可以通过npm进行包文件下载;

    项目中安装包的命令
        npm install 包的完整名称    可以在项目中安装指定名称的包文件;
            也可以简写为: npm i 完整的包名称

        初次装包完成后,项目文件夹下多出一个node_modules的文件夹和package-lock.json的配置文件,其中:
            node_modules文件夹用于存放所有已安装到项目中的包,require()导入第三方包时,就是从这个目录中查找并加载包;
            
            package-lock.json配置文件用于记录node_modules目录下每个包的下载信息,包含包的名字,版本号和下载地址等;

    安装指定版本的包
        使用npm install命令时默认自动安装最新版本的包,如需安装指定版本包,可以在报名后通过@符号,指定具体版本,如: npm i moment@2.22.2

    包的语义化版本规范
        包的版本号以'点分十进制'形式进行定义,总共三位数字,例如2.23.0,其中每一位数字代表含义:
            第一位数字: 大版本
            第二位数字: 功能版本
            第三位数字: Bug修复版本

        版本号提升的规则: 只要前面的版本号增长了,则后面的版本号归零;

    包管理配置文件
        npm规定在项目根目录中,必须提供一个叫做package.json的包管理配置文件,用于记录于项目有关的一些配置信息:
            1.项目的名称,版本号,描述等
            2.项目中用到了哪些包,哪些只在开发阶段使用,哪些在开发和部署阶段都会用等

        第三方包体积过大,不便团队成员键共享项目源码问题处理:共享时踢出node_modules;项目开发中,一定要将node_modules文件夹,添加到.gitignore忽略文件中;

        快速创建package.json
            npm init -y: npm包管理工具的快捷命令,可以在执行命令目录中快速创建package.json文件,注意:
                1.上述命令只能在英文目录下成功运行,项目文件夹必须使用英文,且不能出现空格;
                2.运行npm install命令时,npm包管理工具会自动将包名称和版本号,记录到package.json中;

        dependencies节点
            专门记录npm install命令安装了哪些包文件;

        一次性安装所有的包
            当拿到一个剔除了node_modules的项目后,需要先将所有包下载到项目中才能运行起来,否则会有模块不存在的错误抛出;

            可以运行npm install 或 npm i,npm包管理工具会一次性安装所有的依赖包;

        卸载包
            可以运行npm uninstall 包名 命令,来卸载指定的包;执行成功后会把卸载的包,自动从package.json的dependencies中移除掉;

        devDependencies节点
            只在开发阶段使用,上线后不使用的包,建议记录到devDependencies节点中,对应开发和线上都要用的包则建议记录到dependencies节点中(写在哪里可以参考包文档);
            
            npm i 包名 -D (完整: npm install 包名 --save-dev)

        解决下包速度慢的问题
            使用淘宝NPM镜像服务器(切换npm下包镜像源),下包镜像源,指的就是下包的服务器地址;
        
            nrm
                为了更方便切换下包的镜像源,可以安装nrm这个小工具,利用nrm提供的终端命令,可以快速产科和切换下包的镜像源;

        包分类
            1.项目包
                被安装进项目的node_modules目录中的包都是项目包,项目包又分为两类:
                    开发依赖包:记录到devdependencies节点中包,只在开发期间会用到
                    核心依赖包:记录到dependencies节点中的包,在开发期间和项目上线后都会用到;

            2.全局包
                执行npm install命令时,如果提供-g参数,则会把包安装为全局包,全局包默认安装到c:\users\用户目录\appdata\roaming\npm\node_modules目录下;

                1.只有工具性质的包,才有全局安装的必要性,因为他们提供了好用的终端命令;
                2.判断某个包是否需要全局安装后才使用,可以参考官方提供的使用说明;

            i5ting_toc
                是一个可以把md文档转为html页面的小工具

            规范的包结构
                一个规范的包,它的内部组成结构必须符合以下3点需求:
                    1.包必须以单独的目录而存在
                    2.包的顶级目录下必须要包含package.json这个包管理配置文件
                    3.package.json中必须包含name,version,main这三个属性,分别代表包的名字(必须唯一),版本号,包的入口

        发布包
            注册npm账号
                1.访问www.npmjs.com网站,注册账号
                2.填写账号相关信息,点击create an account按钮,注册账号;
                3.邮箱上验证链接

            登陆npm账号
                npm账号注册完成后,在终端中执行npm login命令,一次输入用户名,密码,邮箱后登陆成功;需注意执行npm login命令之前,必须先把下包服务器地址切换为npm的官方服务器,否则会导致发布包失败;

            把包发布到npm上
                终端切换到包的根目录之后,运行npm publish命令,即可将包发布到npm上(包名不能雷同)

            删除已发布的包
                运行npm unpublish 包名 --force 命令,即可从npm删除已发布的包;
                1.npm unpublish命令只能删除72小时内发布的包
                2.npm unpublish删除的包,在24小时内不允许重复发布
                3.发布包时要慎重,尽量不要往npm上发布无意义的包


##模块加载机制
    优先从缓存中加载
        模块在第一次加载后会被缓存,这也意味着多次调用require()不会导致模块的代码被执行多次;不论是内置模块,用户自定义模块还是第三方模块,它们都会优先从缓存中加载,从而提高模块的加载效率;

    内置模块的加载机制
        内置模块是由Node.js官方提供的模块,内置模块的加载优先级最高;如require('fs')始终返回内置的fs模块,即使在node_modules目录下有名字相同的包也叫fs;

    自定义模块的加载机制
        使用require()加载自定义模块时,必须指定./或../开头的路径标识符,在加载自定义模块时如果没有指定./或../这样的路径标识符,则node会把它当做内置模块或第三方模块进行加载,同时在使用require()导入模块时,如果省略了文件扩展名,则node.js会按顺序分别尝试加载以下文件:
            1.按照确切的文件名进行加载
            2.补全.js扩展名进行加载
            3.补全.json扩展名进行加载
            4.补全.node扩展名进行加载
            5.加载失败,终端报错

    第三方模块的加载机制
        如果传递给require()的模块标识符不是一个内置模块,也没有以./或../开头,则node.js会从当前模块的父目录开始,尝试从/node_modules文件夹中加载第三方模块;如果没有找到对象对应的第三方模块,则移动到再上一层父目录汇总,进行加载,知道文件系统的根目录c:/node_modules/tools

    目录作为模块
        当把目录作为模块标识符,传递给require()进行加载时,有三种加载方式:
            1.在被加载目录下查找一个package.json文件,并寻找main属性,作为require()加载的入口
            2.如果目录中没有package.json文件,或main入口不存在或无法解析,则node.js会试图加载目录下的index.js文件;
            3.如以上两步都失败,则node.js会在终端打印错误消息,报告模块缺失: Error:Cannot find module 'xxx';


##Express
    express是基于node.js平台的快速,开放,极简的web开发框架,它的作用和node.js内置的http模块类似,是专门用来创建web服务器的npm第三方包,提供了快速创建web服务器的便捷方法;

    不使用express也可用node.js原生的http模块,只是用起来很复杂,开发效率低,express可以极大提高开发效率,二者的关系类似于浏览器中web api与jquery的关系,后者是基于前者进一步封装出来的;

    express能做什么
        使用express可以方便快捷的创建web网站的服务器或api接口的服务器:
            1.web网站服务器:专门对外提供web网页资源的服务器
            2.api接口服务器:专门对外提供api接口的服务器

    express的基本使用
        1.安装  npm i express@4.17.1
        2.创建基本的web服务器
            (1)导入express
            (2)创建web服务器
            (3)调用app.listen(端口号,启动成功后的回调函数),启动服务器
        3.监听请求
            app.get()方法监听GET请求
            app.post()方法监听POST请求
        4.获取url中携带的查询参数
            req.query 可以访问到客户端通过查询字符串的形式,发送到服务器的参数(默认情况下是空对 象);
        5.获取url中的动态参数
            req.params 可以访问到url中,通过:匹配到的动态参数(例如'/user/:id')
        6.把内容响应给客户端
            res.send()可以把处理好的内容发送给客户端

    托管静态资源
        1.express.static()
            通过它可以非常方便的创建一个静态资源服务器,例如通过如下代码可以将public目录下的图片,css文件和js文件对外开放访问:
                app.use(express.static('public'));
            express在指定的静态目录中存放文件,并对外提供资源的访问路径,因此存放静态文件的目录名不会出现在url中;

        2.托管多个静态资源目录
            如果要托管多个静态资源目录,则多次调用express.static()即可,访问静态资源文件时,express.static()会根据目录的添加顺序查找所需的文件;

        3.挂载路径前缀
            如希望在托管的江天资源访问路径前挂载路径前缀,可使用如下方式:
                app.use('/public',express.static('public'));
            
    nodemon
        nodemon这个工具可以监听项目文件的变动,当代码被修改后,nodemon会自动帮助重启项目,避免了频繁的手动close然后重新启动,极大的方便了开发和调试;
        
        安装nodemon
            npm install -g nodemon

        使用
            node xx.js 启动项目,坏处是代码被修改后需要手动重启项目;
            nodemon xx.js 启动项目,好处是代码被修改后会被nodemon监听到,从而实现自动重启项目的效果;  


##Express路由
    广义上来讲,路由就是映射关系(例如手机上10086下按键与服务之间的映射关系),在express中路由指的是客户端的请求与服务器处理函数之间的映射关系;express中路由分3部分组成:1.请求的类型 2.请求的url地址 3.处理函数
        app.METHOD(PATH,HANDLER)

    路由匹配过程
        请求到达服务器后,需先经过路由的匹配,匹配成功后才会调用对应处理函数,按路由顺序匹配,如果请求类型和请求的url同时匹配成功,则express会将此次请求,转交给对应function处理;

    路由的使用
        1.最简单的用法
            在express中使用路由最简单方式,就是把路由挂载到app上

        2.模块化路由
            为方便对路由进行模块化的管理,express不建议将路由直接挂载到app上,而是推荐将路由抽离为单独的模块,步骤如下:
                1.创建路由模块对应的.js文件
                2.调用express.Router()函数,创建理由对象
                3.向路由对象上挂载具体的路由
                4.使用module.exports向外共享路由对象
                5.使用app.use()函数注册路由模块

        3.创建路由模块
            const router = express.Router()
            ...
            module.exports = router  //向外导出路由对象

        4.注册路由模块
            const router = require('./03.router')
            app.use('/api', router) //app.use()函数用于注册全局中间件

        5.为路由模块添加前缀
            类似于托管静态资源时,为静态资源统一挂载访问前缀一样,路由模块添加前缀的方式也非常简单:
            app.use('/api',router)


##Express中间件
    中间件(Middleware),特指业务流程中的中间处理环节,当一个请求到达express的服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理;express中间件本质上就是一个function处理函数,中间件函数的形参列表中必须包含next参数,而路由处理函数中只包含req和res;

    next()函数的作用
        next函数是实现多个中间件连续调用的关键,它表示把流转关系转交给下一个中间件或路由;

    定义最简单的(全局)中间件函数
        app.use((req, res, next) => {
          ...
          next()
        })
        多个全局中间件之间使用next()进行链接

    中间件的作用
        多个中间件之间共享一份req和res,基于这个特性,可以在上游的中间件中统一为req和res对象添加自定义的属性或方法,供下游的中间件或路由进行使用;

    局部生效的中间件
        不使用app.use()定义的中间件,叫做局部生效的中间件;
        const mw1 = (req, res, next) => {
            console.log('调用了局部生效的中间件')
            next()
        }

        app.get('/', mw1, (req, res) => {
            res.send('Home page.')
        })

    中间件的5个使用注意事项
        1.一定要在路由之前注册中间件
        2.客户端发送过来的请求,可以连续调用多个中间件进行处理
        3.执行完中间件的业务代码之后,不要忘记调用next()函数
        4.为了防止代码逻辑混乱,调用next()函数后不要再写额外的代码
        5.连续调用多个中间件时,多个中间件之间,共享req和res对象

    中间件的5大分类
        1.应用级别的中间件
            通过app.use()或app.get()或app.post(),绑定到app实例上的中间件,叫做应用级别中间件;

        2.路由级别的中间件
            绑定到express.Router()实例上的中间件,用法与应用中间件没有区别,只是应用中间件绑定到app实例,路由中间件绑定到router实例上;

        3.错误级别的中间件
            专门用于捕获整个项目中发生的异常错误,从而防止项目异常崩溃的问题,错误级别的function处理函数中,必须有4个形参,形参顺序从前到后,分别为(err,req,res,next),普通的只有后三个;

        4.express内置的中间件
            express内置了3个常用中间件:
                1.express.static    快速托管静态资源的内置中间件,如html,css,图片等
                2.express.json  解析json格式的请求体数据(仅支持4.16.0+)
                    如果没有配置任何解析表单数据的中间件，则 req.body 默认等于 undefined
                3.express.urlencoded    解析url-encoded格式的请求体数据(仅支持4.16.0+)
                    基于body-parser这个第三方中间件进一步封装出来的

        5.第三方的中间件
            非express官方的第三方开发出的中间件,项目中可以按需下载并配置第三方中间件,从而提高开发效率,如3express 4.16.0之前版本中,经常使用body-parser这个第三方中间件来解析请求体数据:
                1.运行npm install body-parser安装中间件
                2.使用require导入中间件
                3.调用app.use()注册并使用中间件

    CORS跨域资源共享
        cors(cross-origin resource sharing,跨域资源共享)由一系列http响应头组成,这些http响应头决定浏览器是否阻止前端js代码跨域获取资源,浏览器的同源安全策略默认阻止网页跨域获取资源,但如果接口服务器配置了cors相关的http响应头,就可以解除浏览器端的跨域访问限制;

        通过安装第三方中间件cors,可以很方便的解决跨域问题,使用步骤如下:
            1.运行 npm install cors  安装中间件
            2.使用 const cors = require('cors') 导入中间件
            3.在路由之前调用 app.use(cors())    配置中间件

        cors的注意事项
            1.cors主要在服务器端进行配置,客户端浏览器无序做任何额外的配置,即可请求开启了cors的接口;
            2.cors在浏览器中有兼容性,只有支持xmlhttprequest level2的浏览器(例如:ie10+,chrome4+,firefox3.5+),才能正常访问开启了cors的服务器端口;

        cors响应头
            Access-Control-Allow-Origin: <origin> | *
                origin参数的值指定了允许访问该资源的指定外域url,也可以通配符*允许任意域的请求;

            Access-Control-Allow-Headers
                客户端发送了额外的请求,需要服务器端进行额外请求头信息的声明,否则此次请求失败;

            Access-Control-Allow-Methods
                指明实际请求所允许使用的http方法;

    cors请求的分类
        客户端在请求cors接口时,根据请求方式和请求头的不同,可以将cors的请求分为两大类:
            1.简单请求
                请求方式:get,post,head三者之一
                http头部信息不超过以下字段: 无自定义头部字段,Accept....

                客户端与服务器之间只会发生一次请求

            2.预检请求
                请求方式:get,post,head之外的请求Method类型
                请求头包含自定义头部字段,向服务器发送了application/json格式的数据

                在浏览器与服务器正式通信之前,浏览器会先发送OPTION请求进行预检,以获知服务器是否允许该实际请求,所以这一次OPTION请求称为预检请求,服务器成功响应预检请求之后,才会发真正的请求,并且携带真实数据;

                客户端与服务器之间会发生两次请求,OPTION预检请求成功之后,才会发起真正的请求;


##Mysql数据库
    数据库(database)是用来组织,存储和管理数据的仓库,用户可以对数据库中的数据进行新增,查询,更新和删除等;

    常见的数据库及其分类
        传统型数据库:mysql(区分community-社区免费版 + enterprise-收费版),oracle(收费),SQL server(收费)
        非关系型(NoSQL)数据库:mongodb

    传统数据库的数据组织结构
        数据库(database),数据表(table),数据行(row),字段(field)

    标记删除
        使用delete语句,会把数据从表中物理删除,为保险起见推荐使用标记删除的形式来模拟删除操作,标记删除就是在表中设置类似于status这样的状态字段,来标记当前这条数据是否被删除;


























