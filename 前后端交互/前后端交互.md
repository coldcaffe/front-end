##服务器对外提供了哪些资源
    查看资源信息
        1.进入chrome开发者模式
        2.点击network中DOC选项,然后刷新页面

    网页中如何请求数据
        数据也是服务器对外提供的一种资源,资源必然要通过 请求-处理-响应 的方式获取;
        如果要在网页中请求服务器上的数据资源,需要用到XMLHttpRequest(xhr)对象,xhr是浏览器提供的js对象,通过它可以请求服务器上的数据资源; var xhrobj = new XMLHttpRequest();

    资源请求方式
        客户端请求服务器时请求方式有多种,最常见的有get和post请求
            get:通常用于获取服务端资源(向服务器要资源)
            post:常用于向服务器提交数据(往服务器发送资源)


##了解Ajax
    Ajax全称Asynchronous JavaScript And XML(异步JavaScript和XML),在网页中通过XMLHttpRequest对象和服务器进行数据交互的方式就是Ajax;Ajax可以更轻松的实现网页与服务器之间的数据交互;

    Ajax的典型应用场景
        搜索提示: 当输入搜索关键字时,通过ajax的形式动态加载搜索提示列表
        数据分页显示: 点击页码时,通过ajax的形式根据页码值动态刷新表格的数据
        数据的增删改查: 数据的增删改查,都需要通过ajax的形式来实现数据的交互


##jQuery中的Ajax
    浏览器提供的XMLHttpRequest用法比较复杂,所以jquery对XMLHttpRequest进行封装,提供了一些列ajax相关函数,极大地降低了Ajax的使用难度;最常用三个方法如下:
        $.get()     语法: $.get(url,[data],[callback])
                        url         要请求的资源地址
                        data        请求资源期间要携带的参数
                        callback    请求成功时的回调函数

        $.post()    语法: $.post(url,[data],[callback])
                        url         要提交的资源地址
                        data        要提交的数据
                        callback    数据提交成功时的回调函数

        $.ajax()    是一个功能比较综合的函数,允许进行更详细的配置
            $.ajax({
                type: '',   //请求方式,如get或post(大小写均可)
                url: '',    //请求的url地址
                data: {},   //请求要携带的数据
                success: function(res){}    //请求成功后的回调函数
            })


##接口
    使用ajax请求数据时,被请求的URL地址,就叫做数据接口,同时每个接口必须要有请求方式;

    接口文档
        接口文档可以包含很多信息,也可以按需进行精简,不过一个合格的接口文档,应该包含一下6项内容,从而为接口调用提供依据:
            1.接口名称: 用来标识各个接口的简单说明,如登陆接口等
            2.接口URL: 接口的调用地址
            3.调用方式: 接口的调用方式 get/post
            4.参数格式: 接口要传递的参数,每个参数必须包含参数名称,参数类型,是否必选,参数说明这4项内容
            5.响应格式: 接口的返回值的详细描述,一般包含数据名称,数据类型,说明等3项内容
            6.返回示例(可选): 通过对象的形式,例举服务器返回数据的格式


##Form表单
    表单在网页中主要负责数据采集功能,HTML中的<form>标签就是用于采集用户输入信息,然后通<form>标签的提交操作,把采集到的信息提交到服务端进行处理;

    表单的组成部分
        1.表单标签  <form></form>
        2.表单域    包含文本框,密码框...等等<input>相关类型提交信息
        3.表单按钮  <button type = 'submit'>

    <form>标签的属性
        <form>标签用来采集数据,<form>标签属性则是用来规定如何把采集到的数据发送到服务器
        action      URL地址             规定提交表单时向何处发送表单数据
                    未指定时默认当前页面地址,提交表单后会跳转到该属性指定URL地址;

        method      get/post            规定以何种方式提交表单数据
                    get适合少量简单数据,post适合大量复杂的数据,实际开发用post较多;

        enctype     application/...     规定发送表单数据之前如何进行数据编码
                    application             在发送前编码所有字符(默认)
                    x-www-form-urlencoded   不对字符编码
                    multipart/form-data     使用包含文件上传的表单时必须使用这个
                    text/plain              空格转换为'+',但不对特殊字符编码(很少用)

        target      _blank/_self...     规定在何处打开action URL
                    _blank      在新窗口中打开
                    _self       默认,在相同的框架中打开
                    _parent     在父框架中打开(很少用)
                    _top        在整个窗口中打开(很少用))
                    framename   在指定的框架中打开(很少用)

    表单的同步提交及缺点
        通过点击submit按钮,触发表单提交操作,从而使页面跳转到action URL的行为,叫做表单的同步提交;

        缺点:
            1.form表单提交后页面会发生跳转,跳转到action URL所指向的地址,用户体验很差;
            2.表单同步提交后,页面之前的状态和数据会丢失
        解决方案:   表单只负责采集数据,由Ajax负责将数据提交到服务器

##通过Ajax提交表单数据
    监听表单提交事件
        jquery中有以下两种方式可以坚挺到表单的提交事件:
            $('#form1').submit(function(){...})
            $('#form1').on('submit',function(){...})

    阻止表单默认提交行为
        当监听到表单的提交事件后,可以调用事件的event.preventDefault()函数,来阻止表单的提交和页面的跳转:
            $('#form1').submit(function(e){e.preventDefault()}})
            $('#form1').on('submit',function(e){e.preventDefault()})

    快速获取表单中的数据
        1.serialize()函数       简化表单中数据的获取操作,可以一次性获取到表单中所有数据 
            $(selector).serialize() 在使用serialize()获取数据时,必须为每个表单元素添加                          name属性


##模板引擎
    模板引擎可以根据程序员指定的模板结构和数据,自动生成一个完整的HTML页面(避免代码拼接方式的后续难以维护)

    模板引擎的好处
        1.减少了字符串的拼接操作
        2.时代吗结构更清晰
        3.是代码更易于阅读与维护


#art-template模板引擎
    art-template是一个简约超快的模板引擎(新手友好)

    安装
        1.浏览器中访问art-template的github.io路径
        2.链接右键另存为,下载到本地
        3.通过script标签加载到网页使用

    使用步骤
        1.导入art-template
        2.定义数据
        3.定义模板
        4.调用template函数
        5.渲染HTML结构

    标准语法
        art-template提供了{{}}这种语法格式,在{{}}内可以进行变量,对象属性,三元表达式,逻辑或,加减乘除,或循环数组等输出操作;
        {{value}},{{obj.key}},{{obj['key']}},{{a?b:c}},{{a||b}},{{a+b}}

        原文输出    {{@ value}}
            如果要输出的value值中包含HTML标签结构,则需要使用原文输出,才能保证HTML正常渲染

        条件输出
            如果要实现条件输出,可以在{{}}中使用if...else...的方式,按需输出
            {{if value}} 按需内容 {{/if}}
            {{if v1}} 按需内容 {{else if v2}} 按需输出内容 {{/if}}
        
        循环输出
            可以在{{}}内通过each语法循环数组,当前循环的索引使用$index进行访问,当前的循环项使用$value进行访问
            {{each arr}}
                {{$index}} {{$value}}
            {{/each}}

        过滤器      {{value | filterName}}
            过滤器本质就是一个function函数,语法类似管道操作符,上一个输出作为下一个输入
            template.defaults.imports.filterName = function(value){//return处理结果}


##模板引擎的实现原理
    正则与字符串操作
        exec()函数用于检索字符串中的正则表达式的匹配,如果字符串中有匹配的值,则返回该匹配值,否则返回null;    RegExpObject.exec(string)

        分组
            正则表达式中()包起来的内容表示一个分组,可以通过分组来提取想要的内容;

        字符串的replace函数
            replace()函数用于在字符串中用一些字符替换另一些字符

        多次/while循环replace
            将数据中的值替换到模板中

        自定义模板引擎
            function template(id, data) {
                var str = document.getElementById(id).innerHTML
                var pattern = /{{\s*([a-zA-Z]+)\s*}}/

                var pattResult = null
                while (pattResult = pattern.exec(str)) {
                    str = str.replace(pattResult[0], data[pattResult[1]])
                }
                return str
            }


##Ajax加强&XMLHttpRequest
    XMLHttpRequest简称xhr,是浏览器提供的js对象,通过它可以请求服务器上的数据资源,jquery中的Ajax函数就是基于xhr对象封装出来的;

    使用xhr发起get请求
        1.创建xhr对象
        2.调用opean函数,指定请求方式与url地址
        3.调用send函数,发起ajax请求
        4.监听onreadystatechange事件
            4.1 监听xhr对象的请求状态readyState,与服务器响应的状态status
            4.2 获取服务器响应回的数据responseText

    xhr对象的readyState属性
        readyState属性用于表示当前Ajax请求所处的状态,每个Ajax请求必然处于以下状态之一:
        值      状态                描述
        0       UNSENT              xhr对象已创建,但尚未调用open方法
        1       OPENED              open()方法以备调用
        2       HEADERS_RECEIVED    send()方法已调用,响应头也已被接受
        3       LOADING             数据接受中,此时response属性中已包含部分数据
        4       DONE                Ajax请求完成,意味数据传输已经彻底完成或失败

    使用xhr发起带参数的get请求
        只需在调用xhr.open期间,为url地址指定参数即可('?id=1&...'),这种在url地址后面拼接的参数,叫做查询字符串.查询字符串指的就是在URL末尾加上用于向服务器发送信息的字符串(变量)

        get请求携带参数的本质
            无论使用$.ajax()或是$.get(),又或者直接使用xhr发起get请求,需要携带参数时,本质上都是直接将参数以查询字符串的方式追加到url地址后面,发送到服务器的;

    URL编码与解码
        url中不允许出现中文字符,如果需要包含这样的中文字符,则必须对中文字符进行编码(转义),使用英文字符去表示非英文字符
        url编码的原则:使用安全的字符(无特殊用途或意义的可打印字符),去表示那些不安全的字符

        encodeURI() 编码的函数
        decodeURI() 解码的函数
        由于浏览器会自动对URL地址进行并操作,因此大多数情况下无需程序员关心URL地址的编解码

    使用xhr发起POST请求
        1.创建xhr对象
        2.调用xhr.open()函数
        3.设置Content-Type属性
        4.调用xhr.send()函数,同时指定要发送的数据
        5.监听xhr.onreadystatechange事件


##数据交换格式
    服务器端与客户端进行数据传输与交换的格式,前端领域常用的有xml和json,重点了解json

    XML
        xml(Extensible Markup Landuage)可扩展标记语言,因此xml和html类似,也是标记语言,但是二者没有任何关系;html被设计用于描述网页内容,是网页内容载体;xml设计用于传输和存储数据,是数据的载体;

        缺点
            1.xml格式臃肿,和数据无关代码多,体积大,传输效率低
            2.在js中解析xml较麻烦

    JSON
        json(JavaScript Object Notation)即js对象表示法,json就是js对象和数组的字符串表示法,使用文本表示一个js对象或数组信息,因此json本质就是字符串;json是一种轻量级的文本数据交换格式,作用上类似于XML,专用于计算机与网络间存储和传输数据,但是比XML更小,更快,更易解析,目前json已经成为了主流的数据交换格式;

        json的两种结构
            json中包含对象和数组两种结构,通过这两种结构的相互嵌套,可以表示各种复杂数据结构

            对象结构
                {key:value,...}的键值对结构,key必须是使用英文的双引号包裹的字符串,value的数据结构可以是数字,字符串,布尔值,null,数组,对象6种类型;

            数组结构
                []括起来的内容,数据结构为["java",19,[...],true...],数组中数据类型可以是数字,字符串,布尔值,null,数组,对象6种类型;

            json语法注意事项
                1.属性名必须使用双引号包裹
                2.字符串类型的值必须使用双引号包裹
                3.json中不允许使用单引号表示字符串
                4.json中不能写注释
                5.json的最外层必须是对象或数组格式
                6.不能使用undefined或函数作为json的值

            json和js对象的互转
                JSON.parse()        从json字符串转换为js对象,json反序列化
                JSON.stringify()    从js对象转为json字符串,json序列化

            序列化和反序列化
                序列化:把数据对象转换为字符串的过程
                反序列化:把字符串转换为数据对象的过程


##封装自己的Ajax函数
    处理data参数
        itheima.js


##XMLHttpRequest Level2的新特性
    旧版XMLHttpRequest的缺点
        1.只支持文本数据的传输,无法用来读取和上传文件
        2.传输和接受数据时,没有进度信息,只能提示有没有完成
    
    XMLHttpRequest level2的新功能
        1.可以设置HTTP请求的时限
        2.可以使用FormData对象管理表单数据
        3.可以上传文件
        4.可以获得数据传输的进度信息

    设置http请求时限
        有时Ajax操作很耗时,网速慢时会让用户久等,新版本增加了timeout属性,可以社会中http请求时限: xhr.timeout = 3000;过了这个时限就自动停止http请求,与此配套的还有一个timeout事件,用于指定回调函数:
            xhr.ontimeout = function(event){
                alert('请求超时')
            }

    FormData对象管理表单数据
        ajax操作往往用来提交表单数据,为了方便表单处理,html5新增了一个formdata对象,可以模拟表单操作;formdata对象也可以用来获取网页表单的值;

    上传文件
        新版xmlhttprequest对象,不仅可以发送文本信息,还可以上传文件
        1.定义UI结构
        2.验证是否选择了文件
        3.向FormData中追加文件
        4.使用xhr发起上传文件的请求
        5.监听onreadystatechange事件

    显示文件上传进度
        新版本xmlhttprequest对象中可以通过xhr.upload.onprogress事件,来获取到文件的上传进度;结合bootstrap的进度条,可以实现上传进度展示;


##jQuery高级用法
    jquery实现文件上传


    jquery实现loading效果
        1.ajaxStart(callback)   ajax请求开始时,执行ajaxStart函数,可以在ajaxStart的callback中显示loading效果;
            $(document).ajaxStart(function(){ //自1.8开始,该方法只能被附加到文档
                $('#loading').show();
            })
        $(document).ajaxStart()会监听当前文档内所有的ajax请求;

        2.$(document).ajaxSop(callback) ajax请求结束时执行,可以在callback中隐藏loading效果


##axios
    axios是专注于网络数据请求的库,相较于原生的xmlhttprequest对象,axios简单易用,而相较于jquery,axios更加轻量化,只专注于网络数据请求;

    axios发起get请求
        axios.get('url', { params: {/*参数*/}}).then(callback)

    axios发起post请求
        axios.post('url', { /*参数*/}).then(callback)

    直接使用axios发起请求
        axios提供了类似jquery中$.ajax()的函数

        axios({
        method: '请求类型,get/post',
        url: '请求url地址',
        data: {/*post数据*/}
        params: {/*get参数*/}
      }).then(callback)


##同源策略和跨域
    同源策略
        如果两个页面的协议,域名和端口(默认80)都相同,则两个页面具有相同的源
        同源策略(same origin policy)是浏览器提供的一个安全功能,限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互,这是一个用于隔离潜在恶意文件的重要安全机制
            1.无法读取非同原网页的cookie,localstorage和indexedDB
            2.无法接触非同源网页的DOM
            3.无法向非同源地址发送ajax请求

    跨域
        同源指两个url的协议,域名,端口一致,反之则为跨域,浏览器允许发起跨域请求,但是跨域请求回来的数据会被浏览器拦截,因此无法被页面获取到;

        如何实现跨域请求
            跨域请求主要2种解决方案: JSONP和CORS
            jsonp:出现的早,兼容性好(兼容低版本IE),缺点是只支持get请求,不支持post请求
            cors:出现的晚,是W3C标准,属于跨域ajax的根本解决方案,支持get和post请求,但是不兼容低版本ie


##JSONP
    jsonp的实现原理
        由于浏览器同源策略限制,网页中无法通过ajax请求非同源的接口数据,但是<script>标签不受浏览器同源策略的影响,因此可以通过src属性,用函数调用的形式请求非同源的js脚本,接受跨域接口响应的数据;

    jsonp的缺点
        由于jsonp是通过<script>的src属性来实现跨域数据获取的,因此只支持get数据请求,不支持post请求;此外jsonp和ajax没有任何关系,不能把jsonp请求数据的方式叫做ajax,因为jsonp没有用到xmlhttprequest这个对象;

    jquery中的jsonp
        jquery中的ajax函数,除了可以发起真正的ajax数据请求外,还能够发起jsonp数据请求
            $.ajax({
                url: '',
                // 代表我们要发起JSONP的数据请求
                dataType: 'jsonp',
                //发送到服务器端的参数名称,默认值为callback
                jsonp: 'callback',
                //自定义的回调函数名称,默认值为jQeuryxxx格式(不自己定义就会随机生成一个)
                //默认情况下使用jquery发起jsonp请求,请求链接上会自动携带一个callback=jQueryxx的参数  // (jQueryxx是随机生成的一个回调函数名称)
                jsonpCallback: 'abc',
                success: function (res) {...}
            })

            如果想要自定义jsonp的参数及回调函数,可以通过jsonp和jsonpCallback两个参数来指定;

    jquery中jsonp的实现过程
        jquery中jsonp也是通过<script>标签的src属性实现跨域数据访问,只是jquery采用的是动态创建和移除<script>标签的方式,来发起jsonp数据请求
            1.发起jsonp请求时,动态向<header>中append一个<script>标签;
            2.在jsonp请求成功后,动态从<header>中移除刚才append进去的<script>标签;


##防抖和节流
    防抖策略(debounce)是当事件被触发后,延迟n秒后再执行回调.如果在这n秒内事件又被触发,则重新计时;好处是可以保证事件在一定时间段内不会频繁被触发执行;

    防抖的应用场景
        用户在输入框内输入字符串时,可通过防抖策略,只在输入完后才执行查询的请求,这样可以有效减少请求次数,节约请求资源;

    节流
        节流策略(throttle),顾名思义可以减少一段时间内事件的触发频率;

    节流的应用场景(节流阀)
        1.鼠标连续不断的触发某事件(如点击),只在单位时间内只触发一次;
        2.懒加载时要监听计算滚动条的位置,但不必每次滑动都触发,可以降低计算的频率,而不必去浪费cpu资源;

        鼠标跟随效果

    防抖和节流的总结
        防抖: 如果事件被频繁触发,防抖能保证只有最后一次触发生效,前面N多次的触发都被忽略;
        节流: 如果事件被频繁触发,截流能够减少事件触发的频率,因此节流是有选择性的执行一部分事件;


##HTTP协议
    通信协议(Communication Protocol)是指通信的双方完成通信所必须遵守的规则和约定;

    互联网通信中的HTTP协议
        客户端与服务端之间要实现网页内容的传输,通信双方必须遵守网页内容的传输协议,网页内容又叫做超文本,因此网页内容的传输协议又叫做超文本传输协议(hyperText Transfer Protol),简称HTTP协议

    http协议的交互模型
        采用了请求/响应的交互模型


##http请求消息
    由于http协议属于客户端浏览器和服务器之间的通信协议,因此客户端发起的请求叫做http请求,客户端发送到服务器的消息叫做http请求消息;http请求消息又叫做HTTP请求报文;

    http请求消息的组成部分
        http请求消息由请求行(request line),请求头部(header),空行和请求体4个部分组成;

        请求行
            由请求方式,url和http协议版本3个部分组成,它们之间使用空格隔开;

        请求头部
            用于描述客户端的基本信息,从而把客户端相关信息告知服务器,比如User-agent 用来说明当前是什么类型浏览器;content-type用于描述发送到服务器的数据格式;accept用于描述客户端能够接收到什么类型的返回内容;accept-language用于描述客户端期望接收那种人类语言的文本内容;

            请求头部由多行键值对组成,每行的键和值之间用英文的冒号分隔;

        空行
            最后一个请求头字段的后面是一个空行,通知服务器请求头部至此结束,请求消息中的空行用于分隔请求头部与请求体;

        请求体
            请求体中存放的是要通过post方式提交到服务器的数据,只有post有请求体,get没有

    http请求方法
        http请求方法,属于http协议的一部分,请求方法的作用是:用来表名要对服务器上的资源执行的操作,最常见的请求方法是get和post;

        请求方法如下: get,post,put,delete  head,options,connect,trace,patch



##http响应状态码
    http响应状态码(HTTP status code),也属于http协议的一部分,用来标识响应的状态,响应状态码会随着响应消息一起被发送至客户端浏览器,浏览器根据服务器返回的响应状态码,就能知道此次http请求的结果是成功还是失败;

    http响应状态码的组成及分类
        http状态码由三个十进制数字组成,第一个十进制数字定义了状态码的类型,后两个数字用来对状态码进行细分,http状态码共分为5种类型: 1xx,2xx,3xx,4xx,5xx;

    1. 2xx 成功相关的响应状态码,表示服务器已经成功接收到请求并进行处理;
    2. 3xx 重定向相关响应状态码,表示服务器要求客户端重定向,需要客户端进一步操作,以完成资源请求;
    3. 4xx 客户端错误相关响应状态码,表示客户端的请求有非法内容,从而导致这次请求失败;
    4. 5xx 服务端错误相关的响应状态码,表示服务器未能正常处理客户端的请求而出现意外错误;


##http响应消息
    http响应消息就是服务器响应给客户端的消息内容,也叫做响应报文;

    http响应消息的组成部分
        http响应消息由状态行,响应头部,空行和响应体4个部分组成;

    状态行
        状态行由http协议版本,状态码和状态码的描述文本3个部分组成,它们之间用空格隔开; 

    响应头部
        响应头部用于描述服务器的基本信息,响应头部由多行键/值对组成,每行的键值之间用英文的冒号分隔;  

    空行
        在最后一个响应头部字段结束之后,会紧跟一个空行,用于通知客户端响应头部至此结束,响应消息中的空行用来分隔响应头部与响应体;

    响应体
        响应体中存放了服务器响应给客户端的资源内容;


##大事件项目
    layui,iconfont,cropper
    

## Node.js
    为什么js可以在浏览器中被执行
        不同的浏览器使用不同的js解析引擎:
        Chrome      V8(性能最好,推荐使用)
        Firefox     OdinMonkey(奥丁猴)
        Safri       JSCore
        IE          Chakra(查克拉)
        etc...

    为什么js可以操作DOM和BOM
        每个浏览器都内置了DOM和BOM这样的API函数,因此浏览器中的js才可以调用他们

    Node.js简介
        node.js是一个基于Chrome v8引擎的js运行环境,作为一个js的运行环境,node提供了基础的功能和api,基于node的这些基础功能,很多强大的工具和框架如雨后春笋出现,大前端生态:
            1.基于Express框架,可以快速构建Web应用
            2.基于Electron框架,可以构建跨平台的桌面应用
            3.基于restify框架,可以快速构建API接口项目
            4.读写和操作数据库,创建使用的命令行工具辅助前端开发,etc...

    环境安装
        node.js官网下载安装包,然后在计算机上双击安装即可;

        区分LTS版本和Current版本不同
            1.LTS为长期稳定版,推荐追求稳定的企业级项目使用
            2.CUrrent为新特性尝鲜版,推荐热衷尝试新特性用户使用,不推荐企业级项目中使用current版本;

        查看已安装的node.js的版本号
            打开终端,在终端(win + r后,输入cmd)中输入命令 node -v后,按下回车键,即可查看已安装的node.js的版本号;

        node.js环境中运行js
            cmd或powershell中,使用node 文件名.js方式执行js

            终端中快捷键
                windows中powershell或cmd,可以通过如下快捷键来提高操作效率:
                1.使用'上箭头',可以快速定位到上一次执行的命令
                2.使用tab键,快速补全路径
                3.使用esc,快速清空当前已输入命令
                4.使用cls,清空终端


##fs文件系统模块
    fs是node官方提供用于操作文件的模块,提供了一系列的方法和属性,满足对文件的操作需求:
        1.fs.readFile()     用于读取指定文件中的内容
            fs.readFile(path[,options],callback)
                path        文件路径
                options     可选参,表示以什么编码格式来读取文件
                callback    文件读取完成后,通过回调函数拿到读取的结果

        2.fs.writeFile()    用于向指定的文件中写入内容
            fs.writeFile()(file,data[,options],callback)
                file        文件路径字符串
                data        要写入的内容
                options     可选参,表示以什么编码格式来写入文件,默认utf8
                callback    文件写入完成后的回调函数

        如果要在js代码中使用fs模块操作文件,需要按如下方式导入: const fs = require('fs');

    fs模块-路径动态拼接的问题
        使用fs模块操作文件时,如果提供的操作路径是以./或../开头的相对路径时,很容易出现路径动态拼接错误的问题(代码运行时,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径)

        解决方案: 
            1.在使用fs模块操作文件时,直接提供完整的路径,不要提供./或../开头的相对路径,从而防止路径动态拼接的问题(但是移植性差,不利于维护);
            2.使用__dirname表示当前文件所处的目录(__是双下划线)

    path路径模块
        path模块是node.js官方提供,用来处理路径的模块,提供了一系列的方法和属性,用于解决用户对路径的处理需求:
            const path = require('path')    导入path模块

            path.join()     将多个路径片段拼接成一个完整的路径字符串
                path.join([...paths])
                    ...paths<string>:   路径片段的序列('../'具有抵消前一个文件夹目录路径的功能)
                    返回值:             <string>
                凡是设计路径拼接的操作,都要用path.join()处理,不能直接用'+'进行字符串拼接
            
            path.basename() 可以获取路径中的最后一部分,用于从路径字符串中将文件名解析出来
                path.basename(path[,ext])
                    path<string>    必选,表示一个路径的字符串
                    ext<string>     可选,表示文件扩展名
                    返回:           <string>,表示路径中的最后一部分(文件名)


























































































